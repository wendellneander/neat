<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Neural Network Visualization</title>
  <style>
    canvas {
      border: 1px solid black;
    }
  </style>
</head>

<body>
  <canvas id="neural-network-canvas" width="800" height="600"></canvas>
  <script>
    function fetchJSONFile(url, callback) {
      var xhr = new XMLHttpRequest();
      xhr.overrideMimeType("application/json");
      xhr.open("GET", url, true);
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 4 && xhr.status === 200) {
          callback(xhr.responseText);
        }
      };
      xhr.send(null);
    }

    fetchJSONFile("result.json", function (response) {
      const data = JSON.parse(response);
      const genomes = data.logs.find(d => d.key === 'BestGenome');
      drawAllGenomes([genomes.data], 'neural-network-canvas');
    });

    function drawAllGenomes(genomes, canvasId) {
      const canvas = document.getElementById(canvasId);
      const ctx = canvas.getContext('2d');

      function drawNode(x, y, radius, id, type) {
        ctx.beginPath();
        ctx.arc(x, y, radius, 0, 2 * Math.PI);
        ctx.fillStyle = 'black';
        ctx.fill();
        ctx.stroke();

        ctx.font = '12px Arial';
        ctx.fillStyle = 'black';
        ctx.fillText(`${id} - ${type}`, x - 4, y - 20);
      }

      function drawConnection(x1, y1, x2, y2, color) {
        ctx.beginPath();
        ctx.moveTo(x1, y1);
        ctx.lineTo(x2, y2);
        ctx.strokeStyle = color;
        ctx.stroke();
      }

      function getNodePositions(genomes, nodes, xOffset) {
        const inputNodes = nodes.filter(node => node.type === 'input');
        const outputNodes = nodes.filter(node => node.type === 'output');
        const hiddenNodes = nodes.filter(node => node.type === 'hidden');

        const inputNodePositions = inputNodes.map((node, i) => ({
          id: node.id,
          type: node.type,
          x: xOffset + (i + 1) * (canvas.width / (genomes.length * (inputNodes.length + 1))),
          y: canvas.height * 0.07
        }));

        const outputNodePositions = outputNodes.map((node, i) => ({
          id: node.id,
          type: node.type,
          x: xOffset + (i + 1) * (canvas.width / (genomes.length * (outputNodes.length + 1))),
          y: canvas.height * 0.95
        }));

        const hiddenNodePositions = hiddenNodes.map((node, i) => ({
          id: node.id,
          type: node.type,
          x: xOffset + (i + 1) * (canvas.width / (genomes.length * (hiddenNodes.length + 1))),
          y: Math.floor(Math.random() * (canvas.height - 40 + 1)) + 40
        }));

        return [...inputNodePositions, ...outputNodePositions, ...hiddenNodePositions];
      }

      function drawGenome(genome, xOffset) {
        const nodePositions = getNodePositions(genomes, genome.nodeGenes, xOffset);

        genome.connectionGenes.forEach(connection => {
          const inNodePos = nodePositions.find(pos => pos.id === connection.inNode);
          const outNodePos = nodePositions.find(pos => pos.id === connection.outNode);
          const color = connection.enabled ? 'green' : 'red';

          if (connection.enabled)
            drawConnection(inNodePos.x, inNodePos.y, outNodePos.x, outNodePos.y, color);
        });

        nodePositions.forEach(pos => {
          if (genome.connectionGenes.some(c => (c.inNode === pos.id || c.outNode === pos.id) && (c.enabled)))
            drawNode(pos.x, pos.y, 10, pos.id, pos.type);
        });
      }

      genomes.forEach((genome, index) => {
        const xOffset = index * canvas.width / genomes.length;
        drawGenome(genome, xOffset);
      });
    }
  </script>
</body>

</html>